#!/usr/bin/env node
import { program } from "commander"
import { version } from "../package.json"
import yaml from "yaml"
import { Convert, type Config } from "./config.js"
import {
  readFileSync,
  writeFileSync,
  existsSync,
  mkdirSync,
  cpSync,
} from "node:fs"
import { execa } from "execa"
import { transformStrings } from "./utils.js"
import { replacePlaceholders } from "./placeholders.js"
import degit from "degit"
import { rimrafSync } from "rimraf"
import type { BuiltData } from "./built-data.js"
import { getAllModules, getAllResolvers } from "./modules.js"
import { loadSchema } from "./schema-loader.js"
import path from "node:path"
import * as detectPackageManager from "detect-package-manager"

program
  .version(version)
  .option(
    "-c, --config <path>",
    "Path to the configuration file",
    ".graphinx.yaml"
  )
  .option("--build-area <path>", "Path to the build area", ".build")
  .option("-k, --keep", "Keep the build area after building", false)
  .parse(process.argv)

const options = program.opts()

if (!existsSync(options.config)) {
  console.error(`Config file not found: ${options.config}`)
  process.exit(1)
}

const { modules, ...restOfConfig } = Convert.toConfig(
  JSON.stringify(yaml.parse(readFileSync(options.config, "utf-8")))
)

const config: Config = {
  ...transformStrings(restOfConfig, replacePlaceholders),
  modules: {
    ...modules,
    index: transformStrings(modules?.index, replacePlaceholders),
  },
}

const DEFAULT_TEMPLATE = "ewen-lbh/graphinx/packages/template"
const buildAreaDirectory = path.resolve(options.buildArea)

console.info(`Building site in ${buildAreaDirectory}`)

if (!options.keep && existsSync(buildAreaDirectory))
  rimrafSync(buildAreaDirectory)

let templateSpecifier = config.template ?? DEFAULT_TEMPLATE
console.info(`Using template ${templateSpecifier}`)

if (!existsSync(buildAreaDirectory)) {
  mkdirSync(path.dirname(buildAreaDirectory), { recursive: true })
  if (!templateSpecifier.includes("#")) templateSpecifier += "#main"
  const emitter = degit(templateSpecifier, {
    verbose: true,
  })

  emitter.on("info", (info) => {
    if ("message" in info) console.info(info.message)
  })
  await emitter.clone(buildAreaDirectory)
}

const templateConfig = JSON.parse(
  readFileSync(path.join(buildAreaDirectory, "package.json"), "utf-8")
)

let injectionPath = "src/data.generated.ts"

if ("graphinx" in templateConfig && templateConfig.graphinx?.inject) {
  injectionPath = templateConfig.graphinx.inject
} else {
  console.warn(
    `Warning: No inject configuration found in template's package.json. If you're the template author, add a graphinx > inject field to your package.json. Set it to the file path you want Graphinx to inject built data into. Defaulting to ${injectionPath}`
  )
}

const schema = await loadSchema(config)
console.log(`Loaded ${Object.keys(schema.types).length} types from schema`)

const resolvers = await getAllResolvers(schema, config)

const builtData: BuiltData = {
  modules: await getAllModules(schema, config, resolvers),
  resolvers,
  schema,
  config,
}

const typescriptDecl = `// This file is generated by Graphinx. Do not edit.
import type { BuiltData } from 'graphinx';
export const data: BuiltData = ${JSON.stringify(builtData, null, 2)};`
const jsdocDecl = `// This file is generated by Graphinx. Do not edit.
/** @type {require('graphinx').BuiltData} */
export const data = ${JSON.stringify(builtData, null, 2)};`

mkdirSync(path.join(buildAreaDirectory, path.dirname(injectionPath)), {
  recursive: true,
})

writeFileSync(
  path.join(buildAreaDirectory, injectionPath),
  injectionPath.endsWith(".ts") || injectionPath.endsWith(".tsx")
    ? typescriptDecl
    : jsdocDecl
)

// Copy over pages from pages directory
if (config.pages) {
  // TODO destination configurable by template
  console.info(
    `Copying pages from ${config.pages} into ${path.join(buildAreaDirectory, "src/routes")}`
  )
  cpSync(config.pages, path.join(buildAreaDirectory, "src/routes/"), {
    recursive: true,
  })
}

// Dump PUBLIC_* env vars into a .env file
const envVars = Object.entries(process.env)
  .filter(([key]) => key.startsWith("PUBLIC_"))
  .map(([key, value]) => `${key}=${value}`)
  .join("\n")

writeFileSync(path.join(buildAreaDirectory, ".env"), envVars)

const packageManager = await detectPackageManager.detect({
  cwd: buildAreaDirectory,
})

console.info("Installing template's dependencies...")

await execa(packageManager, ["install"], {
  cwd: buildAreaDirectory,
  stdio: "inherit",
})

console.info("Building site...")

await execa(packageManager, ["run", "build"], {
  cwd: buildAreaDirectory,
  stdio: "inherit",
})

console.info("âœ… Site built")

if (!options.keep) rimrafSync(buildAreaDirectory)
